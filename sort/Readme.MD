
```
- Best-case scenario: the input array is already sorted.

- Worst-case scenario: the input array is sorted in reverse order.

- Average-case scenario: the input array is randomly ordered.
```

# 1. Bubble Sort:

### Time complexity:
```
Best-case: O(n) | Worst-case: O(n^2) | Average-case: O(n^2)

- Space complexity: O(1)
```

# 2. Insertion Sort:

### Time complexity:
```
Best-case: O(n) | Worst-case: O(n^2) | Average-case: O(n^2)

- Space complexity: O(1)
```

# 3. Selection Sort:

### Time complexity:
```
Best-case: O(n^2) | Worst-case: O(n^2) | Average-case: O(n^2)

- Space complexity: O(1)
```

# 4. Merge Sort:

### Time complexity:
```
Best-case: O(n log n) | Worst-case: O(n log n) | Average-case: O(n log n)

- Space complexity: O(n)
```

# 5. Quick Sort:

### Time complexity:
```
Best-case: O(n log n) | Worst-case: O(n^2) | Average-case: O(n log n)

- Space complexity: O(log n) - in-place version, O(n) - normal version
```

# 6. Heap Sort:

### Time complexity:
```
Best-case: O(n log n) | Worst-case: O(n log n) | Average-case: O(n log n)

- Space complexity: O(1)
```

Counting Sort

Time Complexity: O(n+k), where k is the maximum value in the array
Space Complexity: O(n+k)
Radix Sort

Time Complexity: O(d*(n+k)), where d is the number of digits in the maximum number, and k is the base of the number system used
Space Complexity: O(n+k)
Bucket Sort

Time Complexity: O(n^2) worst case, O(n) average case
Space Complexity: O(n+k), where k is the number of buckets
